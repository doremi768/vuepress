# 前端技术要点

## 1. 页面路由跳转

<font color="#FA8072"> uni-app </font> 中的页面路由跳转有两种方式，使用 <font color="#FA8072">navigator</font> 组件跳转、调用 <font color="#FA8072">API</font> 跳转。在项目中所有的跳转我都采用的是调用 <font color="#FA8072">API</font> 跳转，我个人比较喜欢这种方式，让我逻辑变得清晰。如下：

```js
//跳转到首页
//在uni-app中明确规定跳转到 tabBar 页面只能使用 switchTab 跳转
uni.switchTab({
  url: "/pages/home/home",
});

//跳转到登录页
//这个api会保留当前页面，跳转到应用内的某个页面，使用uni.navigateBack可以返回到原页面。
uni.navigateTo({
  url: "/pages/login/login",
});
```

## 2. 搜索用户功能

对于这个板块，我的构思是  
1.调用 `/searchUser`API,当搜索关键字后，后端通过关键字对数据库中用户个人信息表的用户名或者邮箱进行搜索匹配，匹配成功后就将搜索到的用户信息返回给前端。  
2.调用`/friendStatus`API,通过查询用户关系表，获取到当前账号用户与其他用户之间的关系，然后返回给前端。  
3.将当前搜索到的用户与用户关系表中的状态进行关联。0 表示请求中，2 表示已经为好友，可以发送消息，3 表示两个用户之间没有任何关系，显示加好友按钮。

技术层面，我采用 <font color="#FA8072">uni-app</font> 对 <font color="#FA8072">Promise</font> 进行封装的 API,<font color="#FA8072">uni.request()</font>，然后通过 <font color="#FA8072">Promise.all</font> 同时获取到两次网络请求的异步结果。之后再将获取到的用户信息与用户关系进行遍历，匹配。如下代码(伪代码)：

```js
//请求搜索用户的信息
const p1 = uni.request({
  url: this.$url + "/searchUser",
  method: "POST",
  data: {
    searchUser: this.searchUser,
    meId: meInfo._id,
  },
});
//请求用户与用户之间的关系
const p2 = uni.request({
  url: this.$url + "/friendStatus",
  method: "post",
  data: { meId: meInfo._id },
});

Promise.all([p1, p2])
  .then((res) => {
    //用户的个人信息
    const [userErr, userData] = res[0];
    //用户与用户之间的关系状态
    const [statusErr, statusData] = res[1];
    if (userData.status === 200 && statusData.status === 200) {
      //得到搜索到的用户数据
      let usersList = userData.data;
      //得到用户与用户之间的关系状态
      let userStatus = statusData.data;
      usersList.forEach((users) => {
        users.btn = "加好友";
        users.btnStatus = 3;
        userStatus.forEach((status) => {
          if (meInfo._id == status.meId) {
            switch (status.friendStatus) {
              case 0:
                users.btn = "请求中";
                users.btnStatus = 0;
                break;
              case 2:
                users.btn = "发消息";
                users.btnStatus = 2;
                break;
            }
          }
        });
      });
      this.searchUserList = usersList;
    }
  })
  .catch((err) => {
    console.log(err);
  });
```

## 3. 聊天页面消息自动滚动

对于聊天页面消息自动滚动我采用的是 <font color="#FA8072">scroll-view</font> 组件的 <font color="#FA8072">scroll-into-view</font> 属性,再配合 <font color="#FA8072">Vue.js</font> 提供的 <font color="#FA8072">Vue.\$nextTick()</font> 实现消息自动滚动。

<font color="#FA8072">scroll-into-view</font> 这个属性的作用是通过设置某子元素的 id 值，再设置哪个方向可滚动，则在哪个方向滚动到该元素。

使用 <font color="#FA8072">Vue.$nextTick()</font> 则是因为，当我发送消息时需要将消息向上推，这种情况数据会发送变化，为了在数据变化之后等待 Vue 完成更新 DOM ，所以在数据变化之后我使用 <font color="#FA8072">Vue.$nextTick(callback)</font> 这样回调函数在 DOM 更新完成后就会调用。
如下(伪代码)：

```js
<template>
   <scroll-view :scroll-into-view="scrollToView">
       <view class="main"  v-for="(item,index) in chatList" :key="index" :id="'msg'+item.tip">
       </view>
   </scroll-view>
</template>

<script>
export default{
	data() {
		return {
			scrollToView: ''
		}
       },
       methods: {
           sendMsg() {
               this.$nextTick(() => {
                   //回调函数中的 this 将自动绑定到当前的 Vue 实例上
                   //maxpages - page * 10 - 1这只是一个下标。
				this.scrollToView = 'msg' + this.chatList[maxpages - page * 10 - 1].tip;
			})
           }
       }
}
</script>
```

## 4.发送语音

我这个项目中发送语音的功能就是操作一些文档给出的 API,实现录制语音，播放语音，暂停播放等控制。项目中这类操作也特别多，所以我就列举一个较为繁琐的发送语音操作，如下（伪代码）:

```js
//项目中我把发送消息，表情，图片，语音等抽成了一个组件调取使用
ChatBox.vue

//获取全局唯一的录音管理器 recorderManager
const recorderManager = uni.getRecorderManager();
//创建并返回内部 audio 上下文 innerAudioContext 对象。
const innerAudioContext = uni.createInnerAudioContext();
//是否自动开始播放
innerAudioContext.autoplay = true;

methods: {
    //点击录音触发
    startRecord() {
	    //显示蒙层
        this.mask = true;
	    //计算音频时间
	    this.timer = setInterval(()=>{
        this.index++;
        //开始录音
        recorderManager.start();
        //最长录制时间我设定的是60秒
		if(this.index == 60){
			clearInterval(this.timer)
		}
	},1000)
   },
   //取消录音
   stopRecord(){
       recorderManager.onStop((res) => {
        this.voicePath = res.tempFilePath;
        //清空音频文件
        this.voicePath = '';
	});
   }，
   //点击发送触发
endRecord(){
	 //得到音频
	 recorderManager.onStop((res) => {
		 //得到音频文件
	    this.voicePath = res.tempFilePath;
		let msgObj = {
			voice: this.voicePath,
			time: this.index
           }
           //2表示发送的消息是音频文件。
		this.sendMsg(msgObj,2)
		this.index = 0;
	 });
},
}
```





