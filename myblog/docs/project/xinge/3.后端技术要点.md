# 后端技术要点

## 1. post 请求变成 option 请求的问题

对于这个问题，当时困扰了我很久。其实这半年来我觉得我已经养成了发现 bug ,能对症下药快速解决的能力。但这次遇到的问题我花了比较久的时间。我经过反思之后，发现其实对于 <font color="#FA8072">http</font> 这块还了解的特别肤浅。于是针对这个项目中遇到的这个问题，我进行了比较详细的了解。

当时出现这个问题，后端报错 <font color="red">Cannot set headers after they are sent to the client</font>。翻译过来的意思是说已经将`response` 信息返回给客户端后，不能再设置 `headers`。比较疑惑的就是我的后端根本就没有接收到前端发送的请求，但却显示已经响应给前端。后来终于在控制台的 <font color="#FA8072">NeteWork</font> 中找到了问题所在。我写的请求方法是 `POST` ，在 <font color="#FA8072">NeteWork</font> 中却变成了 `OPTIONS`。

后面我针对 `OPTIONS` 请求，搜集了一些资料之后发现，在特定请求下浏览器会在实际调用接口之前，首先发送出一个 `options` 请求，检测服务端是否支持真实的请求，进行跨域的请求。然后，浏览器根据 `OPTIONS` 请求返回的结果来决定是否继续发送真实的请求进行跨域资源访问。

而浏览器在两种特定的情况下会自动产生的 `OPTIONS` 请求：

### 1. 产生了复杂请求   


复杂请求对应的就是简单请求。简单请求的定义是：
>1. 请求方法是GET、HEAD或者POST，并且当请求方法是POST时， <font color="#FA8072">Content-Type</font> 必须是 <font color="#FA8072">application/x-www-form-urlencoded</font> , <font color="#FA8072">multipart/form-data</font> 或着 <font color="#FA8072">text/plain</font>中的一个值。

| 首部字段Content-Type   | 在响应中告诉客户端实际返回的内容的内容类型。(字段值用type/subtype形式赋值)  |
|  :-:  | :-: |
| application/x-www-form-urlencoded | 表单默认的提交数据的格式 |
| multipart/form-data  | 需要在表单中进行文件上传时，就需要使用该格式 |
| text/plain | 纯文本格式 |


>2. 请求中没有自定义HTTP头部。

:::tip
所谓的自定义头部，在实际的项目里，我们经常会遇到需要在 <font color="#FA8072">header</font> 头部加上一些 <font color="#FA8072">token</font> 或者其他的用户信息，用来做用户信息的校验
:::

### 2. 发生了跨域

官方将头部带**自定义信息**的请求方式称为**带预检（preflighted）的跨域请求**，通过上面的梳理，对于这句话的理解也变得比较清晰。


### 解决方案

>1. 使用代理，避开跨域。
>2. 将复杂跨域请求更改为简单跨域请求。
>3. 不使用带自定义配置的 <font color="#FA8072">header</font> 头部。


所以这样服务器会给出两次及以上响应，而我的解决方法就是清理掉第一次浏览器发送的预检跨域请求返回的响应，代码（部分关键代码）如下：

```js
app.all('*', function (req, res, next) {
    if(req.method == 'OPTIONS') {
        res.sendStatus(200);
    } else {
        next();
    }
  });
```

## 2. 整理数据

我将路由抽离成单独的文件，如下：

```js
//引入路由
require('./router/router')(app);
//引入附件上传路由
require('./router/file')(app);
```

在路由页面，接收到前端发来的请求之后，调用相应的方法对前端数据进行整理，如下：

```js
const trimData = require('../trim/trimData');

//验证邮箱是否已被注册。
app.post('/signInEmail',(req,res) => {
    trimData.signInEmail(req,res)
});

//同意用户添加好友请求
app.post('/agreeFriendReq',(req,res) => {
    trimData.agreeFriendReq(req,res);
})
```

在 trimeData.js 中将前端的数据取出来，然后针对不同的需求进行数据库的增删改查，如下：

```js
//通过 users.js 操作用户个人信息表
const users = require('../dbCRDU/users');
//通过 friendList.js 操作用户与用户关系表
const friendList = require('../dbCRDU/friendList');

exports.signInEmail = function (req,res){
    const {email} = req.body;
    users.signInEmailTest(email,res);
}

exports.agreeFriendReq = function(req,res){
    const {agreeId,status} = req.body;
    friendList.agreeFriendReq(agreeId,status,res);
}
```

## 3. 后端与数据库交互

我列举几个做项目时，常用的对数据库操作的方式：
### 1. 搜索用户
```js
users.js

const dbmodel = require('../model/dbmodel');
let userModel = dbmodel.model('User'); 

//搜索用户
exports.searchUser = function(searchUser,meId,res){
    let users = new RegExp(searchUser,'i');
    userModel.find({
        $or : [ //只要搜索到邮箱、用户名其中的字符有一个匹配到了搜索关键字就返回。
            {username : {$regex : users}},
            {email : {$regex : users}}
        ],
        _id:{$ne:meId}  //排除掉我自己
    },{signature: 0,password:0,sex: 0,birthDay: 0},function(err,data){
        if(err){
            res.send({status: 500})
        }else{
            //整理数据库中的数据
            res.send({status:200,data})
        }
    })
}

```
### 2. 请求添加好友的用户个人信息

```js
users.js

const dbmodel = require('../model/dbmodel');
let userModel = dbmodel.model('User'); 

exports.reqFriendsInfo = function(usersId,res) {
    let usersInfo = [];
    let index = 0;
    //遍历出每个用户的id
    usersId.forEach(id => {
        //通过用户id这个条件对数据库进行查询
        userModel.find({_id:id},function(err,data){
            if(err) {
                res.send({status: 500});
            } else {
                //将每次查询到的结果放入数组中
                usersInfo.push(data[0]);
                index++;
                if(index === usersId.length) {
                    res.send({status:200,usersInfo});
                }
            }
        })
    })
}
```

### 3.与用户的关系判断
```js
friendList.js  

const dbmodel = require('../model/dbmodel');
let friendListModel = dbmodel.model('friendList');  

exports.searchUser = function(meId,res){
    friendListModel.find({
        $or:[
            {meId:meId},
            {userId:meId}
        ]
        },{meId:1,userId:1,friendStatus:1},function(err,data){
        if(err) {
            res.send({status:500})
        } else {
          res.send({status: 200,data})    
        }
    })
}
```