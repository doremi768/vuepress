## 通过Vuex进行状态管理

此定位功能的实现是借助于高德JS API提供了 `AMap.Geolocation`插件来实现定位。对于获取到的地理信息的数据，我使用的是 `Vuex`进行状态管理。如下:
```js
//App.vue
function onComplete (data) {
  // data是具体的定位信息
  this.$store.dispatch('setLocation',data);
  this.$store.dispatch('setAddress',data.formattedAddress);
}
```
上面代码是我通过 `this.$store.dispatch` 触发 `Action`,并分别将定位的信息和详细的地理位置以载荷的形式分发。然后将载荷进行提交。如下：
```js
//store
actions: {
  setLocation: ({commit},location) => {
    commit(types.SET_LOCATION,location)
  },
  setAddress: ({commit},address) => {
    commit(types.SET_ADDRESS,address)
  }
}
```
上面的代码就是载荷提交的过程，`{commit}` 这个对象实际上是通过ES2015的解构赋值，解构 `context` 对象，来简化代码。而如 `types.SET_LOCATION` 是我参照了 [Vuex文档](https://vuex.vuejs.org/zh/guide/mutations.html),从而使用常量来替代了 `mutation` 事件类型。

我还在 `store` 中定义了 `'getter'`,将依赖缓存起来，方便后续访问。如下：
```js
//store
getters: {
   location: state => state.location,
   address: state => state.address
}
```
`Home.vue` 中，也就是首页，在`computed` 中通过 `Getter` 暴露的 `store.getters` 对象访问依赖。并将数据渲染到页面。如下(部分代码)：
```js
//Home.vue
city(){
   return this.$store.getters.location.addressComponent.city;
}
```
然后通过 `$router` 访问路由实例，调用 `this.$router.push` 导航到 `Address.vue`。如下：
```js
//Home.vue
@click="$router.push({name:'address',params:{city: city}})"
```
这样做的好处是 `router.push` 这个方法会向 `history` 栈添加一个新的记录。

## 城市列表排序
在 `Address.vue` 这个页面，我实现的核心功能有：定位信息展示、搜索框根据关键字检索位置信息等。对于搜索框关键字检索信息位置，我使用的是高德提供的输入提示插件 `AMap.PlaceSearch` 。由于这些功能比较简单就不再赘述。

对于当时的我来说定位功能的较难点是将城市列表以字母表的顺序排序，我在高德中引入行政区查询服务的插件，然后遍历出城市信息。并存放在 `Set`数据结构中。而按照字母表排序我是借鉴了百度中一段代码，封装了一个函数得以实现，如下：
```js
function sorts(arr) {
	let letters = "*abcdefghjklmnopqrstwxyz".split('');
	let zh = "阿八嚓哒妸发旮哈讥咔垃痳拏噢妑七呥扨它穵夕丫帀".split('');
	let allCity = [];
	let cityObj;
	//将字母进行遍历
	letters.forEach(function(item, i) {
		//将字母存入 cityObj.letter 中
		cityObj = {letter: item,data: []};
		//遍历传入进来的城市名
		arr.forEach(function(item2) {
            /**
             * zh[i-1]： 是用来过滤掉第一次判断
             * zh[i-1].localeCompare(item2) <= 0 ： 将 zh 当前索引的上一个元素和城市名进行比较。
             * item2.localeCompare(zh[i]) == -1： 将当前城市名和 zh 当前索引的元素进行比较。
             * 这其实就是字母表排序最为核心的代码，这用以判断了当前城市名所在的字母区间，从而确定了是否将放入cityObj.data中。
             * */
			if ((!zh[i - 1] || zh[i - 1].localeCompare(item2) <= 0) && item2.localeCompare(zh[i]) == -1) {
				cityObj.data.push(item2);
			}
		});
		//判断当前字母中是否有城市名
		if (cityObj.data.length) {
			allCity.push(cityObj);
			//将同一个字母开头的城市名按照字母顺序进行排序
			cityObj.data.sort(function(a, b) {
				return a.localeCompare(b);
			});
		}
	});
	return allCity;
}
```
