# 对象
对象是是引用数据类型，但通过测试发现，<font color="#FA8072">typeof</font> 检测 <font color="#FA8072">null</font> 的数据类型的时候，却返回的是 <font color="#FA8072">'object'</font>。如下：
```js
console.log(typeof null); // 'object'
```
对于此现象，在《《你不知道的JavaScript》》一书中，有着比 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof)更通透的解释：

> 不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为0的话会被判断为 <font color="#FA8072">object</font> 类型， null 的二进制表示是全0，所以执行 <font color="#FA8072">typeof</font> 时会返回 <font color="#FA8072">'object'</font>

对象是一个深不可测的知识，在此我就对对象的一些属性进行总结。

## 属性描述符
在 ES5 之前，JavaScript语言并没有提供可以直接检测属性特性的方法，但是从ES5开始，所有的属性都具备了属性描述符。
### Object.getOwnPropertyDescriptor()
方法返回指定对象上一个 <font color="#3EAF7C">**自有属性**</font> 对应的 <font color="#3EAF7C">**属性描述符**</font>。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）
```js
let obj = {
	a: 1
};
console.log(Object.getOwnPropertyDescriptor(obj,'a'));  //第一个参数：要查找的目标对象；第二个参数：目标对象内属性名称
/**
 * configurable: true   //当指定对象的属性描述可以被改变或者属性可被删除时，为true。
 * enumerable: true     //当指定对象的属性可以被枚举出时，为 true。
 * value: 1             //该属性的值(仅针对数据属性描述符有效)
 * writable: true       //只有属性的值可以被改变时为true。(仅针对数据属性描述有效)
*/
```
当然光查看是没有什么用的，真正的魅力在于修改。
### Object.defineProperty()
这个方法会直接在一个对象上定义一个新属性，或者 <font color="#3EAF7C">**修改**</font> 一个对象的现有属性，并返回此对象。

**writable**  
属性描述符的writable设置false，那么就不能修改了，官方术语 <font color="#3EAF7C">静默失败</font><font color="#FA8072">(silently failed)</font>。如果是在严格模式下，则会报错。

**configurable**  
只要属性是 <font color="#3EAF7C">**可配置**</font>的 ，就可以使用 <font color="#FA8072">defineProperty()</font> 方法来<font color="#3EAF7C">**修改属性描述符**</font>。
```js
let obj = {
    a: 1
}
Object.defineProperty(obj,'a',{
value: 2, 
writable: true,  
configurable: false,     //改为不可配置     
enumerable: true,    
});
console.log(obj.a);          //2

Object.defineProperty(obj,'a',{
value: 3, 
writable: true,  
configurable: true,    
enumerable: true,    
});//Uncaught TypeError
```
:::warning
* 不管是不是处于严格模式，尝试修改一个不可配置的属性描述符（除了 <font color="#FA8072">value</font> 和 <font color="#FA8072">writable</font> 属性之外）的值时会抛出 <font color="#FA8072">TypeError</font>，除非当前值和新值相同。  
* 把 <font color="#FA8072">configurable</font> 修改成 <font color="#FA8072">false</font> 是单向操作，无法撤销。  
* 可以把 <font color="#FA8072">writable</font> 的状态由 <font color="#FA8072">true</font> 改为 <font color="#FA8072">false</font> ，但是无法由 <font color="#FA8072">false</font> 改为 <font color="#FA8072">true</font>。
:::

除了无法修改，<font color="#FA8072">configurable:false</font> 还会禁止删除这个属性：
```js
Object.defineProperty(obj,'a',{
value: 3, 
writable: true,  
configurable: false,    
enumerable: true,    
});

console.log(obj.a)  //3
delete obj.a;
console.log(obj.a)  //3
```
上面例子中，<font color="#FA8072">delete</font> 只是用来直接删除对象的(可删除)属性。如果对象的某个属性是某个对象 / 函数的最后一个引用者，对这个属性执行 <font color="#FA8072">delete</font> 操作之后，这个未引用的对象 / 函数就可以被垃圾回收。

**enumerable**  
这个描述符控制的是属性是否会出现在对象的属性枚举中，比如说 <font color="#FA8072">for..in</font> 循环。如果把 <font color="#FA8072">enumerable</font> 设置成 <font color="#FA8072">false</font>,这个属性就不会出现在枚举中，虽然可以正常访问它。
```js
let obj = {
	a: 1,
	b: 2,
	c: 3
};
Object.defineProperty(obj,'a',{
	enumerable: false
});
for(k in obj){
	console.log(obj[k]);    //2 3
}
console.log(obj.a);         //1
```

## 不变性
所有的方法创建都是 <font color="#3EAF7C">**浅不可变性**</font>，换句话说就是它们只会影响 <font color="#3EAF7C">**目标对象**</font> 和它的 <font color="#3EAF7C">**直接属性**</font>。如果目标对象引用了其他对象，其他对象的内容不受影响，但仍然是可变的。比如：
```js
console.log(obj.arr);            //[1,2,3]
obj.arr.push(4);
console.log(obj.arr);            //[1,2,3,4]
```
假设上面代码中的 <font color="#FA8072">obj</font> 已经被创建而且是不可变的，可以看出这是浅不变性，但想要实现深不变性，可以使用下面的一些方法：

### 对象常量  
结合 <font color="#FA8072">writable: false</font> 和 <font color="#FA8072">configurable: false</font> 就可以创建一个真正的常量属性(<font color="#000000">**不可修改、重定义或者删除**</font>)

### 禁止扩展 
如果想禁止一个对象添加新属性并且保留已有属性，就可以使用 <font color="#FA8072">Object.preventExtensions()</font>

**Object.preventExtensions()**  
这个方法的作用就是让一个对象变的 <font color="#3EAF7C">**不可扩展**</font>，返回值是一个已经不可扩展的对象。

在 <font color="#3EAF7C">**非严格模式**</font> 下，创建属性 <font color="#FA8072">a</font> 会静默失败。在 <font color="#3EAF7C">**严格模式**</font> 下，将会抛出 <font color="#FA8072">TypeError</font> 错误，如下：
```js
let obj = {
	a: 1
};
Object.preventExtensions(obj);
obj.b = 2;
console.log(obj.b);		//undefined
```
:::warning
<font color="#FA8072">Object.preventExtensions()</font> 仅阻止添加自身的属性。但其对象类型的原型依然可以添加新的属性。  
该方法使得目标对象的 <font color="#FA8072">[[prototype]]</font> 不可变；任何重新赋值 <font color="#FA8072">[[prototype]]</font> 操作都会抛出 <font color="#FA8072">TypeError</font> 。
:::
上面两句话出自 MDN,对于这两句话，我思考了好一段时间，我把 <font color="#FA8072">[[prototype]]</font> 理解为了 <font color="#FA8072">prototype</font> ,以至于我卡顿了很久，第一句话的原型是 `__proto__` ；而第二句话的 <font color="#FA8072">[[prototype]]</font> 也是  `__proto__` 。  

第一句话：
```js
let obj = {
	a: 1
};
Object.preventExtensions(obj);
obj.__proto__.b = 2;    //obj.__proto__.b === Object.prototype.b
console.log(obj.b);     //2
```

第二句话：
```js
let obj = {
	a: 1
};
Object.preventExtensions(obj);
obj.__proto__ = {b:2};
console.log(obj);       //Uncaught TypeError: #<Object> is not extensible
```

如果使用此方法，传入的参数不是一个对象类型，对于这种情况如下：
:::warning
在 ES5 中，如果参数不是一个对象类型（而是原始类型），将抛出一个<font color="#FA8072">TypeError</font> 异常。  
在 ES2015 中，非对象参数将被视为一个不可扩展的普通对象，因此会被直接返回。（ECMAscript 2015 是在2015年6月份发布的ES6的第一个版本。）
:::
```js
Object.preventExtensions(1);
// TypeError: 1 is not an object (ES5 code)

Object.preventExtensions(1);
// 1                            (ES2015 code)
```

### 密封
**Object.seal()**  
此方法封闭一个对象，阻止添加新属性并将所有现有属性标记为 <font color="#3EAF7C">**不可配置**</font>。当前属性的值只要原来是可写的就可以改变。  

这个方法实际上会在一个现有对象上调用 <font color="#FA8072">Object.preventExtensions()</font> 并把所有现有属性标记为 <font color="#FA8072">configurable: false</font>。在密封之后不仅<font color="#3EAF7C">**不能添加新属性**</font>，也<font color="#3EAF7C">**不能重新配置**</font>或者<font color="#3EAF7C">**删除**</font>任何现有属性。如下：
```js
let obj = {
	a : 1
}
Object.seal(obj);

obj.b = 2;
console.log(obj.b);		//undefined 不能添加

delete a;
console.log(obj.a);		//1		    不能删除

obj.a = 3;
console.log(obj.a);		//3 	    可以修改

Object.defineProperty(obj,'a',{
	configurable: true
});	//Uncaught TypeError: Cannot redefine property: a    不可配置
```
如果使用此方法，传入的参数不是一个对象类型，对于这种情况如下:
:::warning
在ES5中，如果这个方法的参数不是一个（原始）对象，那么它将导致 <font color="#FA8072">TypeError</font>。  
在ES2015中，非对象参数将被视为已被密封的普通对象，会直接返回它。
:::
```js
Object.seal(1);
// TypeError: 1 is not an object (ES5 code)

Object.seal(1);
// 1                             (ES2015 code)
```

### 冻结
**Object.freeze()**  
这个方法会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 <font color="#FA8072">Object.seal()</font> 并把所有'数据访问'属性标记为 <font color="#FA8072">writable: false</font>，这样就无法修改它们的值了。
```js
let obj = {
    a: 1
};
Object.freeze(obj);
obj.a = 2;
console.log(obj.a);     //1
```
<font color="#000000">**这个方法是可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任何直接属性的修改。**</font>

